#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Motor,  mtr_S1_C1_1,     motorLeftFront,   tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     motorLeftBack,   tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     ramp,   tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     arms,   tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorRightFront,   tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     motorRightBack,   tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S1_C4_3,    button,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    button2,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_1,    clawLeft,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    clawRight,               tServoStandard)
#pragma config(Sensor, S2,     LEGOLS,              sensorI2CCustom)
#pragma config(Sensor, S3,     light,              sensorI2CCustom)
#pragma config(Sensor, S4,     HTSMUX,              sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "/hitechnic-sensormux.h"
#include "/lego-ultrasound.h"
#include "/lego-light.h"
#include "/hitechnic-force.h"
#include "/hitechnic-irseeker-v2.h"
#include "/lego-touch.h"
#include "/hitechnic-force.h"
// The sensor is connected to the first port
// of the SMUX which is connected to the NXT port S1.
// To access that sensor, we must use msensor_S1_1.  If the sensor
// were connected to 3rd port of the SMUX connected to the NXT port S4,
// we would use msensor_S4_3

// Give the sensor a nice easy to use namez
const tMUXSensor HTFORCE1 = msensor_S4_1;
const tMUXSensor HTFORCE2 = msensor_S4_2;
const tMUXSensor HTIRS2 = msensor_S4_3;
const tMUXSensor LEGOTS = msensor_S4_4;
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
* $Id: lego-light-SMUX-test1.c 123 2012-11-02 16:35:15Z xander $
*/

/**
* lego-light.h provides an API for the Lego Light Sensor.  This program
* demonstrates how to use that API through a SMUX.
*
* Changelog:
* - 0.1: Initial release
* - 0.2: More comments
*
* License: You may use this code as you wish, provided you give credit where it's due.
*
* THIS CODE WILL ONLY WORK WITH ROBOTC VERSION 3.54 AND HIGHER.
* Xander Soldaat (xander_at_botbench.com)
* 25 November 2009
* version 0.2
*/

#include "/hitechnic-sensormux.h"
#include "/lego-light.h"

// The sensor is connected to the first port
// of the SMUX which is connected to the NXT port S1.
// To access that sensor, we must use msensor_S1_1.  If the sensor
// were connected to 3rd port of the SMUX connected to the NXT port S4,
// we would use msensor_S4_3

// Give the sensor a nice easy to use name
bool on,prevOn;
int lsVal,force1,force2;

/////////////////////////////////Arm Functions///////////////////////////////////
void raiseArm(int powerLevel){
	motor[arms]=powerLevel;
}

void lowerArm(int powerLevel){
	motor[arms]=-powerLevel;
}

//////////////////////////////Movement Functions/////////////////////////////////
void forward(int powerLevel){
	motor[motorLeftBack] = powerLevel;
	motor[motorLeftFront] = powerLevel;
	motor[motorRightBack] = powerLevel;
	motor[motorRightFront] = powerLevel;
}

void reverse(int powerLevel){
	motor[motorLeftBack] = -powerLevel;
	motor[motorLeftFront] = -powerLevel;
	motor[motorRightBack] = -powerLevel;
	motor[motorRightFront] = -powerLevel;
}

void left(int powerLevel){
	motor[motorLeftBack] = 0;
	motor[motorLeftFront] = 0;
	motor[motorRightBack] = powerLevel;
	motor[motorRightFront] = powerLevel;
}

void right(int powerLevel){
	motor[motorLeftBack] = powerLevel;
	motor[motorLeftFront] = powerLevel;
	motor[motorRightBack] = 0;
	motor[motorRightFront] = 0;
}

void diagonalFR(int powerLevel){
	motor[motorLeftBack] = 0;
	motor[motorLeftFront] = powerLevel;
	motor[motorRightBack] = powerLevel;
	motor[motorRightFront] = 0;
}


void rotateLeft(int powerLevel){
	motor[motorLeftBack] = -powerLevel;
	motor[motorLeftFront] = -powerLevel;
	motor[motorRightBack] = powerLevel;
	motor[motorRightFront] = powerLevel;
}

void rotateRight(int powerLevel){
	motor[motorLeftBack] = powerLevel;
	motor[motorLeftFront] = powerLevel;
	motor[motorRightBack] = -powerLevel;
	motor[motorRightFront] = -powerLevel;
}

void stop(){
	motor[motorLeftBack] = 0;
	motor[motorLeftFront] = 0;
	motor[motorRightBack] = 0;
	motor[motorRightFront] = 0;
	motor[arms] = 0;
	motor[ramp] = 0;
}


void updateSensors()
{
	force1=HTFreadSensor(HTFORCE1);
	force2=HTFreadSensor(HTFORCE2);
}


void checkWeightedRing()
{
	//Weighted Ring Checker
	if(force1<1000)
		force1+=1000;
	if(force2<1000)
		force2+=1000;
	if(force1>1450&&force2>1300||force2>1500&&force1>1400){
		if(time1[T1]>350){
			ClearTimer(T1);
			on=!on;
		}
		if(on!=prevOn){
			if(on)
				servo[button2]=0;
			else
				servo[button2]=120;
		}
	}
	else{
		servo[button2]=110;
	}
	if(force1>1455){
		servo[button]=150;
	}
	else if(force2>1460){
		servo[button]=150;
	}
	else{
		servo[button]=140;
	}
	prevOn=on;
}

void init(){
	lsVal = force1 = force2 = 0;
	on = prevOn = false;
}


task main(){
	int my_message;
	bool up=false,on=true,prevOn=true;
	int ser = 0;
	while(true){
		updateSensors();
		//checkWeightedRing();
		//Run Claw Servos
		/*if(ServoValue[servo1]==100&&up&&ServoValue[servo2]==215-ser){
		ser=0;
		up=false;
		}
		if(ServoValue[servo1]==0&&ServoValue[servo2]==215-ser&&!up){
		ser=100;
		up=true;
		}*/
		servo[clawLeft]=ser;
		servo[clawRight]=215-ser;
		//Run lights
		if(time1[T1]>350){
			ClearTimer(T1);
			on=!on;
		}
		if(on!=prevOn){
			if(on)
				servo[button2]=0;
			else
				servo[button2]=120;
		} prevOn=on;
		/////

		//Read the message to variable
		my_message = message;

		//Let's say something got through if the signal is not zero
		if(my_message != 0)
		{
			//Display the value as stored in the variable
			nxtDisplayBigTextLine(2,"1: %d",my_message);

			//Clear the message, set it to 0
			ClearMessage();
		}

		//Checking for a message every half a second is
		//fine for this simple test

		if(my_message==1){
			forward(80);
			nxtDisplayCenteredTextLine(1,"Forward");
		}
		else if(my_message==2){
			reverse(80);
			nxtDisplayCenteredTextLine(1,"Reverse");
		}
		else if(my_message==3){
			rotateLeft(80);
			nxtDisplayCenteredTextLine(1,"Left");
		}
		else if(my_message==4){
			rotateRight(80);
			nxtDisplayCenteredTextLine(1,"Right");
		}
		else if(my_message==100)
			raiseArm(50);
		else if(my_message==101)
			lowerArm(50);
		else if(my_message==5)
			stop();
		else if(my_message==200)
			ser=100;
		else if(my_message==201)
			ser=0;

		wait1Msec(15);

	}
}
